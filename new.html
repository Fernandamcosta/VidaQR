<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Fit City: Neon Warfare - Mobile</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet" />
<style>
:root {
  --neon-green: #00ff41;
  --neon-pink: #ff00de;
  --neon-blue: #00f3ff;
  --neon-yellow: #ffee00;
  --bg-dark: #0a0a12;
}

body {
  margin: 0; overflow: hidden; background: var(--bg-dark);
  font-family: 'Rajdhani', sans-serif; user-select: none;
  touch-action: none; /* Impede zoom e scroll no mobile */
  -webkit-touch-callout: none;
}

/* UI Overlay Style Cyberpunk */
#ui {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10;
  background: radial-gradient(circle at center, transparent 60%, #000 100%);
}

.hud-panel {
  position: absolute; padding: 10px; background: rgba(0, 10, 20, 0.85);
  border: 1px solid var(--neon-blue); border-radius: 4px;
  box-shadow: 0 0 10px rgba(0, 243, 255, 0.2);
  /* Clip path simplificado para mobile */
  clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
}

/* Stats Adaptativo */
.stats-box { 
  top: 15px; left: 15px; width: 250px; 
  transform: skewX(-5deg); 
  max-width: 40vw; /* Limite para telas pequenas */
}
.xp-text { 
  font-family: 'Orbitron'; font-size: 24px; color: #fff; 
  letter-spacing: 2px; text-shadow: 0 0 10px var(--neon-blue); 
}
.speed-indicator { 
  font-size: 12px; color: var(--neon-yellow); margin-top: 2px; font-weight: bold; 
}

.bar-container { height: 8px; background: #222; margin-top: 5px; border: 1px solid #444; }
.hp-fill { height: 100%; background: linear-gradient(90deg, var(--neon-green), #aaffaa); width: 100%; box-shadow: 0 0 10px var(--neon-green); transition: width 0.1s; }

/* Boss HUD Mobile Friendly */
#bossHud {
  display: none; position: absolute; top: 15px; left: 50%; transform: translateX(-50%);
  width: 50vw; flex-direction: column; align-items: center;
}
.boss-title { 
  font-family: 'Orbitron'; color: var(--neon-pink); font-size: 18px; 
  text-transform: uppercase; text-shadow: 0 0 15px var(--neon-pink); 
  letter-spacing: 1px; margin-bottom: 5px; text-align: center;
}
.boss-bar-frame { width: 100%; height: 15px; background: #110000; border: 1px solid var(--neon-pink); transform: skewX(-20deg); padding: 2px; }
.boss-fill { width: 100%; height: 100%; background: var(--neon-pink); box-shadow: 0 0 15px var(--neon-pink); transition: width 0.1s; }

/* Radar & Controls Info (Escondido em mobile muito pequeno) */
.radar-box { 
  bottom: 20px; left: 20px; color: #aecfb2; font-size: 12px; border-color: var(--neon-green);
  display: none; /* Escondido por padr√£o em mobile para limpar a tela */
}
@media (min-width: 768px) {
    .radar-box { display: block; }
}

/* CONTROLES MOBILE */
#mobileControls {
    position: fixed; bottom: 20px; left: 0; width: 100%; height: 150px;
    z-index: 20; pointer-events: none; /* Cliques passam atrav√©s da √°rea vazia */
    display: flex; justify-content: space-between; padding: 0 20px; box-sizing: border-box;
}

.control-region {
    pointer-events: auto; /* Reativa cliques nos bot√µes */
    position: relative;
}

/* Joystick */
#joystickZone {
    width: 120px; height: 120px;
    background: rgba(255, 255, 255, 0.05);
    border: 2px solid rgba(0, 243, 255, 0.3);
    border-radius: 50%;
    position: relative;
    touch-action: none;
}
#joystickKnob {
    width: 50px; height: 50px;
    background: rgba(0, 243, 255, 0.5);
    border-radius: 50%;
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    box-shadow: 0 0 15px var(--neon-blue);
}

/* Action Buttons */
#actionZone {
    display: flex; gap: 20px; align-items: flex-end;
}
.mob-btn {
    width: 70px; height: 70px;
    border-radius: 50%;
    border: 2px solid #fff;
    color: #fff; font-size: 24px;
    display: flex; justify-content: center; align-items: center;
    backdrop-filter: blur(4px);
    touch-action: none; user-select: none;
}
.btn-dash { background: rgba(0, 255, 65, 0.2); border-color: var(--neon-green); }
.btn-attack { background: rgba(255, 0, 222, 0.2); border-color: var(--neon-pink); width: 90px; height: 90px; font-size: 30px; }
.mob-btn:active { transform: scale(0.95); opacity: 0.8; }

/* Alerts */
#bossAlert {
  display: none; position: fixed; top: 35%; width: 100%; text-align: center;
  font-family: 'Orbitron'; font-size: 10vw; /* Responsivo */
  color: var(--neon-pink); font-weight: 900;
  text-shadow: 4px 4px 0 #000, 0 0 50px var(--neon-pink); 
  animation: pulseAlert 0.2s infinite alternate; z-index: 20;
}
@keyframes pulseAlert { from { opacity: 1; transform: scale(1); } to { opacity: 0.8; transform: scale(1.05); } }

/* Game Over Screen */
#gameOver {
  position: fixed; inset: 0; background: rgba(5, 5, 10, 0.95); z-index: 100;
  display: none; flex-direction: column; align-items: center; justify-content: center;
  backdrop-filter: blur(5px);
}
#gameOver h1 { 
  color: var(--neon-pink); font-family: 'Orbitron'; font-size: 12vw; margin: 0; 
  text-transform: uppercase; text-shadow: 0 0 30px var(--neon-pink); text-align: center;
}
button {
  margin-top: 40px; padding: 15px 40px; background: transparent; 
  border: 2px solid var(--neon-green); color: var(--neon-green);
  font-family: 'Orbitron'; font-size: 18px; cursor: pointer; text-transform: uppercase; letter-spacing: 2px;
  transition: all 0.2s; position: relative; overflow: hidden;
}
button:hover, button:active { background: var(--neon-green); color: #000; box-shadow: 0 0 30px var(--neon-green); }

canvas { display: block; image-rendering: pixelated; width: 100%; height: 100%; }
</style>
</head>
<body>

<div id="ui">
  <div class="hud-panel stats-box">
    <div class="xp-text" id="scoreDisplay">0 XP</div>
    <div class="speed-indicator" id="speedDisplay">VEL: 60%</div>
    <div style="display:flex; justify-content:space-between; font-size:10px; margin-top:5px; color:#888;">
      <span>HP</span><span>ATIVO</span>
    </div>
    <div class="bar-container"><div class="hp-fill" id="hpBar"></div></div>
  </div>
  
  <div id="bossHud">
    <div class="boss-title">‚ö†Ô∏è REI DO JUNK FOOD ‚ö†Ô∏è</div>
    <div class="boss-bar-frame"><div class="boss-fill" id="bossBar"></div></div>
  </div>

  <div class="hud-panel radar-box">
    <div style="margin-bottom:5px; color:var(--neon-green)">üéØ OBJETIVO: ELIMINE O FAST FOOD</div>
    <div>üïπÔ∏è WASD Mover | SHIFT Dash | ESPA√áO Socar</div>
  </div>
</div>

<!-- CONTROLES MOBILE -->
<div id="mobileControls">
    <div class="control-region" id="joystickZone">
        <div id="joystickKnob"></div>
    </div>
    <div class="control-region" id="actionZone">
        <div class="mob-btn btn-dash" id="btnDash">‚ö°</div>
        <div class="mob-btn btn-attack" id="btnAttack">‚öîÔ∏è</div>
    </div>
</div>

<div id="bossAlert">BOSS FIGHT!</div>

<div id="gameOver">
  <h1 id="endTitle">FAL√äNCIA</h1>
  <p style="color:#aaa; font-size: 20px; font-family: 'Rajdhani'" id="finalScore">Score: 0</p>
  <button onclick="restartGame()">REINICIAR</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

// --- DETEC√á√ÉO DE MOBILE ---
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 800;

// Ocultar controles mobile se estiver no desktop
if (!isMobile) {
    document.getElementById('mobileControls').style.display = 'none';
}

// --- CONFIGURA√á√ÉO ---
const WORLD_SIZE = 3000;
let camera = { x: 0, y: 0 };
let mouse = { x: 0, y: 0, worldX: 0, worldY: 0 };

let gameActive = true;
let score = 0;
let frame = 0;
let bossSummoned = false;
let bossActive = false;
let difficultyFactor = 0.6;

let player = {
  x: WORLD_SIZE/2, y: WORLD_SIZE/2, size: 30,
  baseSpeed: 7, speed: 7, maxHp: 100, hp: 100,
  angle: 0, 
  isAttacking: false, attackCooldown: 0,
  dashTime: 0, dashCooldown: 0,
  walkFrame: 0,
  ghosts: []
};

let enemies = [];
let items = [];
let particles = [];
let floatingTexts = [];
let mapDecals = [];

// Input agora suporta eixos anal√≥gicos
let input = { 
    axisX: 0, 
    axisY: 0, 
    attack: false, 
    dash: false 
};

// --- REDIMENSIONAMENTO ---
function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// --- INPUTS: TECLADO (DESKTOP) ---
const keys = { w:0, a:0, s:0, d:0 };
function updateKeyAxis() {
    if(!isJoystickActive) { // Teclado s√≥ funciona se n√£o estiver usando o joystick
        input.axisY = keys.s - keys.w;
        input.axisX = keys.d - keys.a;
    }
}
window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
window.addEventListener('keydown', e => {
  let k = e.code;
  if(k === 'KeyW' || k === 'ArrowUp') keys.w = 1;
  if(k === 'KeyS' || k === 'ArrowDown') keys.s = 1;
  if(k === 'KeyA' || k === 'ArrowLeft') keys.a = 1;
  if(k === 'KeyD' || k === 'ArrowRight') keys.d = 1;
  if(k === 'Space') input.attack = true;
  if(k === 'ShiftLeft' || k === 'ShiftRight') input.dash = true;
  updateKeyAxis();
});
window.addEventListener('keyup', e => {
  let k = e.code;
  if(k === 'KeyW' || k === 'ArrowUp') keys.w = 0;
  if(k === 'KeyS' || k === 'ArrowDown') keys.s = 0;
  if(k === 'KeyA' || k === 'ArrowLeft') keys.a = 0;
  if(k === 'KeyD' || k === 'ArrowRight') keys.d = 0;
  if(k === 'Space') input.attack = false;
  if(k === 'ShiftLeft' || k === 'ShiftRight') input.dash = false;
  updateKeyAxis();
});

// --- INPUTS: MOBILE (JOYSTICK & BOT√ïES) ---
const joystickZone = document.getElementById('joystickZone');
const joystickKnob = document.getElementById('joystickKnob');
const btnAttack = document.getElementById('btnAttack');
const btnDash = document.getElementById('btnDash');

let isJoystickActive = false;
let joyCenter = { x:0, y:0 };
const maxJoyDist = 35; // Raio m√°ximo do knob

// Bot√µes
btnAttack.addEventListener('touchstart', (e) => { e.preventDefault(); input.attack = true; }, {passive: false});
btnAttack.addEventListener('touchend', (e) => { e.preventDefault(); input.attack = false; }, {passive: false});
btnDash.addEventListener('touchstart', (e) => { e.preventDefault(); input.dash = true; }, {passive: false});
btnDash.addEventListener('touchend', (e) => { e.preventDefault(); input.dash = false; }, {passive: false});

// L√≥gica Joystick
joystickZone.addEventListener('touchstart', e => {
    e.preventDefault();
    isJoystickActive = true;
    let rect = joystickZone.getBoundingClientRect();
    joyCenter = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
    handleJoystickMove(e.touches[0]);
}, {passive: false});

joystickZone.addEventListener('touchmove', e => {
    e.preventDefault();
    if(isJoystickActive) handleJoystickMove(e.touches[0]);
}, {passive: false});

joystickZone.addEventListener('touchend', e => {
    e.preventDefault();
    isJoystickActive = false;
    input.axisX = 0; input.axisY = 0;
    joystickKnob.style.transform = `translate(-50%, -50%)`;
}, {passive: false});

function handleJoystickMove(touch) {
    let dx = touch.clientX - joyCenter.x;
    let dy = touch.clientY - joyCenter.y;
    let dist = Math.sqrt(dx*dx + dy*dy);
    
    // Normalizar movimento (0 a 1)
    let cappedDist = Math.min(dist, maxJoyDist);
    let angle = Math.atan2(dy, dx);
    
    // Mover visual do knob
    let kx = Math.cos(angle) * cappedDist;
    let ky = Math.sin(angle) * cappedDist;
    joystickKnob.style.transform = `translate(calc(-50% + ${kx}px), calc(-50% + ${ky}px))`;
    
    // Setar input (normalizado)
    input.axisX = dx / maxJoyDist;
    input.axisY = dy / maxJoyDist;
    
    // Clamp input para n√£o ultrapassar 1
    if(dist > maxJoyDist) {
        input.axisX = Math.cos(angle);
        input.axisY = Math.sin(angle);
    }
}

// --- GERAR MAPA ---
function initMap() {
    mapDecals = [];
    for(let i=0; i<50; i++) {
        mapDecals.push({
            x: Math.random() * WORLD_SIZE,
            y: Math.random() * WORLD_SIZE,
            type: Math.random() > 0.5 ? 'manhole' : 'trash',
            rotation: Math.random() * Math.PI * 2
        });
    }
}

// --- L√ìGICA DO JOGO ---
function spawnEnemy(isBoss = false, x=null, y=null) {
    let ex = x, ey = y;
    if (ex === null) {
        let angle = Math.random() * Math.PI * 2;
        let dist = isMobile ? 500 : 700; // Spawn mais perto no mobile
        ex = player.x + Math.cos(angle) * dist;
        ey = player.y + Math.sin(angle) * dist;
        ex = Math.max(100, Math.min(WORLD_SIZE-100, ex));
        ey = Math.max(100, Math.min(WORLD_SIZE-100, ey));
    }

    if (isBoss) {
        bossActive = true;
        bossSummoned = true;
        enemies.push({
            x: ex, y: ey, isBoss: true,
            icon: 'üëπ', hp: 2500, maxHp: 2500,
            speed: 2.2 * difficultyFactor,
            size: 90, summonTimer: 0,
            vx:0, vy:0, hitStun:0
        });
        document.getElementById("bossHud").style.display = 'flex';
        let alert = document.getElementById("bossAlert");
        alert.style.display = "block";
        setTimeout(() => alert.style.display = "none", 3000);
    } else {
        let types = [
            {t:'üçî', hp:50, spd:4, xp:20, sz:30}, 
            {t:'üçü', hp:30, spd:5.5, xp:15, sz:25}, 
            {t:'üçï', hp:80, spd:2.5, xp:30, sz:35}
        ];
        let type = types[Math.floor(Math.random()*types.length)];
        let currentSpeed = type.spd * difficultyFactor;
        enemies.push({
            x: ex, y: ey, isBoss: false,
            icon: type.t, hp: type.hp, maxHp: type.hp,
            speed: currentSpeed, 
            size: type.sz, xp: type.xp,
            vx:0, vy:0, hitStun:0
        });
    }
}

function spawnItem() {
    items.push({
        x: Math.random() * (WORLD_SIZE-100)+50,
        y: Math.random() * (WORLD_SIZE-100)+50,
        icon: ['ü•¶','ü•ï','üçé','üçå'][Math.floor(Math.random()*4)],
        timer: 0
    });
}

function update() {
    if (!gameActive) return;

    // Dificuldade
    difficultyFactor = 0.6 + (score / 2000);
    if(difficultyFactor > 2.5) difficultyFactor = 2.5;

    document.getElementById("speedDisplay").innerText = "VEL: " + Math.floor(difficultyFactor * 100) + "%";
    player.speed = player.baseSpeed * (1 + (difficultyFactor - 0.6) * 0.3);

    // 1. Calcular Angulo
    mouse.worldX = mouse.x + camera.x;
    mouse.worldY = mouse.y + camera.y;
    
    if (isMobile && (Math.abs(input.axisX) > 0.1 || Math.abs(input.axisY) > 0.1)) {
        // No mobile, se estiver movendo, a mira vai para a dire√ß√£o do movimento
        player.angle = Math.atan2(input.axisY, input.axisX);
    } else if (!isMobile) {
        // No desktop, segue o mouse
        player.angle = Math.atan2(mouse.worldY - player.y, mouse.worldX - player.x);
    }

    // 2. Movimento (Usando Axis)
    let moveLen = Math.sqrt(input.axisX*input.axisX + input.axisY*input.axisY);
    
    // Normalizar se for teclado (para n√£o correr mais r√°pido na diagonal)
    // Se for joystick, j√° est√° normalizado ou proporcional
    let mx = input.axisX;
    let my = input.axisY;
    
    if (!isJoystickActive && moveLen > 1) {
        mx /= moveLen; my /= moveLen;
        moveLen = 1;
    }
    
    if (moveLen > 0.1) {
        player.walkFrame += 0.2 * difficultyFactor;
    } else {
        player.walkFrame = 0;
    }

    // Dash
    let spd = player.speed;
    if (player.dashCooldown > 0) player.dashCooldown--;
    if (input.dash && player.dashCooldown <= 0 && moveLen > 0.1) {
        player.dashTime = 12;
        player.dashCooldown = 50;
        createParticles(player.x, player.y, "#00f3ff", 15);
    }
    if (player.dashTime > 0) {
        spd *= 2.8;
        player.dashTime--;
        if (frame % 2 === 0) {
            player.ghosts.push({x: player.x, y: player.y, angle: player.angle, alpha: 0.6, life: 10});
        }
    }

    player.x += mx * spd;
    player.y += my * spd;
    
    // Clamp World
    player.x = Math.max(50, Math.min(WORLD_SIZE-50, player.x));
    player.y = Math.max(50, Math.min(WORLD_SIZE-50, player.y));

    // 3. Combate
    if (player.attackCooldown > 0) player.attackCooldown--;
    if (input.attack && player.attackCooldown <= 0) {
        player.isAttacking = true;
        player.attackCooldown = 20;
        performAttack();
    } else {
        player.isAttacking = false;
    }

    // 4. Inimigos e Spawn
    if (score >= 1000 && !bossSummoned) spawnEnemy(true);
    
    let spawnInterval = Math.floor(100 / difficultyFactor); 
    if(spawnInterval < 20) spawnInterval = 20;

    let cap = bossActive ? 8 : 20 + (score/200); 
    // Reduzir cap no mobile para performance
    if(isMobile) cap *= 0.7;

    if (frame % spawnInterval === 0 && enemies.length < cap) spawnEnemy();

    for (let i = enemies.length - 1; i >= 0; i--) {
        let e = enemies[i];
        
        if (e.isBoss) {
            document.getElementById("bossBar").style.width = (e.hp/e.maxHp*100)+"%";
            e.summonTimer++;
            if(e.summonTimer > (200 / difficultyFactor)) {
                e.summonTimer = 0;
                spawnEnemy(false, e.x + 50, e.y);
                spawnEnemy(false, e.x - 50, e.y);
                spawnText("SERVOS!", e.x, e.y - 100, "#ff00de");
            }
        }

        if (e.hitStun > 0) {
            e.hitStun--;
            e.x += e.vx; e.y += e.vy;
            e.vx *= 0.9; e.vy *= 0.9;
        } else {
            let angle = Math.atan2(player.y - e.y, player.x - e.x);
            e.x += Math.cos(angle) * e.speed;
            e.y += Math.sin(angle) * e.speed;
        }

        enemies.forEach(o => {
            if (e === o) return;
            let d = Math.hypot(e.x - o.x, e.y - o.y);
            if (d < e.size + o.size) {
                let a = Math.atan2(e.y - o.y, e.x - o.x);
                e.x += Math.cos(a); e.y += Math.sin(a);
            }
        });

        let dist = Math.hypot(player.x - e.x, player.y - e.y);
        if (dist < player.size + e.size - 10 && player.dashTime <= 0) {
            if (frame % 15 === 0) {
                player.hp -= e.isBoss ? 15 : 4;
                shakeScreen(e.isBoss ? 10 : 3);
                spawnText("-HP", player.x, player.y-40, "#ff0000");
                createParticles(player.x, player.y, "#ff0000", 3);
            }
        }

        if (e.hp <= 0) {
            if (e.isBoss) {
                gameWin();
            } else {
                score += e.xp;
                createParticles(e.x, e.y, "#ffaa00", isMobile ? 5 : 10); // Menos particulas mobile
                spawnText("+"+e.xp, e.x, e.y, "#ffff00");
            }
            enemies.splice(i, 1);
        }
    }

    // 6. Itens
    if (frame % 120 === 0 && items.length < 5) spawnItem();
    items.forEach((it, i) => {
        it.timer += 0.05;
        if (Math.hypot(player.x - it.x, player.y - it.y) < 40) {
            player.hp = Math.min(player.maxHp, player.hp + 20);
            score += 50;
            spawnText("RECARGA!", player.x, player.y-40, "#00ff41");
            createParticles(it.x, it.y, "#00ff41", 8);
            items.splice(i, 1);
        }
    });

    // 7. C√¢mera
    // Lookahead reduzido no mobile para n√£o ficar tonto
    let lookFactor = isMobile ? 0.15 : 0.3;
    let lookAheadX = (isMobile ? (input.axisX * 150) : (mouse.worldX - player.x)) * lookFactor; 
    let lookAheadY = (isMobile ? (input.axisY * 150) : (mouse.worldY - player.y)) * lookFactor;
    
    // Limits
    lookAheadX = Math.max(-200, Math.min(200, lookAheadX));
    lookAheadY = Math.max(-150, Math.min(150, lookAheadY));

    let targetX = player.x + lookAheadX - canvas.width/2;
    let targetY = player.y + lookAheadY - canvas.height/2;

    targetX = Math.max(0, Math.min(WORLD_SIZE - canvas.width, targetX));
    targetY = Math.max(0, Math.min(WORLD_SIZE - canvas.height, targetY));

    camera.x += (targetX - camera.x) * 0.08;
    camera.y += (targetY - camera.y) * 0.08;

    updateEffects();
    if (player.hp <= 0) { player.hp = 0; gameOver(); }
    
    document.getElementById("hpBar").style.width = (player.hp) + "%";
    document.getElementById("scoreDisplay").innerText = Math.floor(score) + " XP";

    frame++;
}

function performAttack() {
    shakeScreen(5);
    let arc = { x: player.x, y: player.y, angle: player.angle, life: 5 };
    particles.push({ type: 'slash', ...arc });

    enemies.forEach(e => {
        let d = Math.hypot(e.x - player.x, e.y - player.y);
        let range = 140;
        if (d < range) {
            let ang = Math.atan2(e.y - player.y, e.x - player.x);
            let diff = ang - player.angle;
            while(diff > Math.PI) diff -= Math.PI*2;
            while(diff < -Math.PI) diff += Math.PI*2;
            
            // Hitbox do ataque um pouco mais generosa no mobile
            let hitArc = isMobile ? 1.5 : 1.2;
            
            if (Math.abs(diff) < hitArc) {
                e.hp -= player.dashTime>0 ? 80 : 40;
                e.hitStun = 12;
                e.vx = Math.cos(player.angle) * 15;
                e.vy = Math.sin(player.angle) * 15;
                spawnText(player.dashTime>0?"CRIT!":"HIT", e.x, e.y-30, "#fff");
                createParticles(e.x, e.y, "#ff00de", isMobile?3:5);
            }
        }
    });
}

// --- RENDER ---
function draw() {
    ctx.fillStyle = "#050505";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.save();
    
    let sx = 0, sy = 0;
    if (shake > 0) {
        sx = (Math.random()-0.5)*shake; sy = (Math.random()-0.5)*shake;
        shake *= 0.9;
        if(shake < 0.5) shake = 0;
    }
    ctx.translate(-camera.x + sx, -camera.y + sy);

    drawCityBackground();

    ctx.save();
    mapDecals.forEach(d => {
        ctx.translate(d.x, d.y);
        ctx.rotate(d.rotation);
        ctx.fillStyle = "#1a1a24";
        if(d.type === 'manhole') {
            ctx.beginPath(); ctx.arc(0,0,25,0,Math.PI*2); ctx.fill();
            ctx.strokeStyle = "#333"; ctx.stroke();
        } else {
            ctx.fillRect(-15, -10, 30, 20);
        }
        ctx.translate(-d.x, -d.y);
    });
    ctx.restore();

    items.forEach(it => {
        let bob = Math.sin(frame * 0.1) * 5;
        ctx.font = "40px Arial";
        ctx.textAlign = "center"; ctx.textBaseline = "middle";
        ctx.shadowBlur = 15; ctx.shadowColor = "#00ff41";
        ctx.fillText(it.icon, it.x, it.y + bob);
        ctx.shadowBlur = 0;
        ctx.strokeStyle = "#00ff41";
        ctx.beginPath(); ctx.ellipse(it.x, it.y + 20, 15, 5, 0, 0, Math.PI*2); ctx.stroke();
    });

    enemies.forEach(e => {
        ctx.save();
        ctx.translate(e.x, e.y);
        
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.beginPath(); ctx.ellipse(0, e.size/2 + 5, e.size/1.5, e.size/4, 0, 0, Math.PI*2); ctx.fill();

        if (e.hitStun > 0) {
            ctx.scale(1.1, 0.9);
            ctx.filter = "brightness(3) sepia(1) hue-rotate(-50deg)";
        }
        
        ctx.font = (e.size * 1.5) + "px Arial";
        ctx.textAlign = "center"; ctx.textBaseline = "middle";
        ctx.fillText(e.icon, 0, 0);

        if(!e.isBoss) {
            ctx.filter = "none";
            ctx.fillStyle = "black"; ctx.fillRect(-20, -e.size, 40, 5);
            ctx.fillStyle = "#ff00de"; ctx.fillRect(-20, -e.size, 40 * (e.hp/e.maxHp), 5);
        }
        
        if(e.isBoss) {
            ctx.globalCompositeOperation = "screen";
            ctx.strokeStyle = `rgba(255, 0, 222, ${0.4 + Math.sin(frame*0.1)*0.2})`;
            ctx.lineWidth = 4;
            ctx.beginPath(); ctx.arc(0,0, e.size, 0, Math.PI*2); ctx.stroke();
            ctx.globalCompositeOperation = "source-over";
        }
        ctx.restore();
    });

    player.ghosts.forEach(g => {
        ctx.save();
        ctx.translate(g.x, g.y);
        ctx.rotate(g.angle);
        ctx.globalAlpha = g.alpha;
        drawPlayerSprite(true);
        ctx.restore();
    });

    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.fillStyle = "rgba(0,0,0,0.6)"; ctx.beginPath(); ctx.ellipse(0, 15, 15, 6, 0, 0, Math.PI*2); ctx.fill();
    ctx.rotate(player.angle);
    drawPlayerSprite();
    ctx.restore();

    particles.forEach(p => {
        if(p.type === 'slash') {
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(p.angle);
            ctx.strokeStyle = `rgba(0, 243, 255, ${p.life/5})`;
            ctx.lineWidth = 5;
            ctx.beginPath(); ctx.arc(0, 0, 90, -Math.PI/3, Math.PI/3); ctx.stroke();
            ctx.restore();
        } else {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
            ctx.globalAlpha = 1;
        }
    });

    floatingTexts.forEach(t => {
        ctx.font = "bold 16px 'Orbitron'";
        ctx.fillStyle = t.color;
        ctx.strokeStyle = "#000"; ctx.lineWidth = 3;
        ctx.strokeText(t.text, t.x, t.y);
        ctx.fillText(t.text, t.x, t.y);
    });

    ctx.restore();

    // Mouse Cursor apenas se n√£o for mobile
    if (!isMobile) {
        ctx.strokeStyle = "#00f3ff"; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(mouse.x, mouse.y, 8, 0, Math.PI*2); ctx.stroke();
        ctx.fillStyle = "#00f3ff";
        ctx.beginPath(); ctx.arc(mouse.x, mouse.y, 2, 0, Math.PI*2); ctx.fill();
    }
}

function drawCityBackground() {
    let gridSize = 300; 
    let startCol = Math.floor(camera.x / gridSize);
    let endCol = startCol + (canvas.width / gridSize) + 1;
    let startRow = Math.floor(camera.y / gridSize);
    let endRow = startRow + (canvas.height / gridSize) + 1;

    ctx.lineWidth = 40; ctx.strokeStyle = "#151520"; 
    
    for (let c = startCol; c <= endCol; c++) {
        for (let r = startRow; r <= endRow; r++) {
            let x = c * gridSize;
            let y = r * gridSize;

            ctx.fillStyle = "#0e0e15";
            ctx.fillRect(x + 20, y + 20, gridSize - 40, gridSize - 40);

            ctx.strokeStyle = (c+r)%2 === 0 ? "#1a0b2e" : "#0b1a2e"; 
            ctx.lineWidth = 2;
            ctx.strokeRect(x + 20, y + 20, gridSize - 40, gridSize - 40);

            if ((c * r) % 5 === 0) {
                ctx.save();
                ctx.translate(x + gridSize/2, y + gridSize/2);
                ctx.rotate(Math.PI/4);
                ctx.font = "bold 40px 'Orbitron'";
                ctx.fillStyle = "rgba(255, 0, 222, 0.1)";
                ctx.textAlign = "center";
                ctx.fillText("BURGER", 0, 0);
                ctx.restore();
            }
        }
    }
}

function drawPlayerSprite(ghost = false) {
    let walk = Math.sin(player.walkFrame) * 3;
    let handOffset = (player.attackCooldown > 10) ? 25 : 15;
    
    if (ghost) {
        ctx.fillStyle = "#00f3ff";
        ctx.beginPath(); ctx.rect(-12, -12, 24, 24); ctx.fill();
        return;
    }

    ctx.fillStyle = "#222"; 
    ctx.beginPath(); 
    ctx.moveTo(-12, -10); ctx.lineTo(12, -10); ctx.lineTo(14, 15); ctx.lineTo(-14, 15); 
    ctx.fill();

    ctx.fillStyle = "#f0c088";
    ctx.beginPath(); ctx.arc(-14, -8 + walk, 7, 0, Math.PI*2); ctx.fill(); 
    ctx.beginPath(); ctx.arc(14, -8 - walk, 7, 0, Math.PI*2); ctx.fill(); 

    ctx.fillStyle = "#f0c088";
    ctx.beginPath(); ctx.arc(0, 0, 11, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = "#00ff41";
    ctx.fillRect(-11, -10, 22, 5);
    ctx.beginPath();
    ctx.moveTo(-10, -8);
    let tailX = -25 - (player.dashTime > 0 ? 10 : 0);
    let tailY = -15 + Math.sin(frame * 0.5) * 5;
    ctx.lineTo(tailX, tailY);
    ctx.lineTo(tailX+5, tailY+8);
    ctx.fill();

    ctx.fillStyle = "#ff0040";
    ctx.beginPath(); ctx.arc(18, 15 - walk, 8, 0, Math.PI*2); ctx.fill(); 
    let punch = player.isAttacking && player.attackCooldown > 10 ? 20 : 0;
    ctx.beginPath(); ctx.arc(18 + punch, -15 + walk, 8, 0, Math.PI*2); ctx.fill(); 
}

let shake = 0;
function shakeScreen(a) { shake = a; }
function createParticles(x, y, c, n) {
    for(let i=0; i<n; i++) particles.push({x:x, y:y, vx:(Math.random()-0.5)*10, vy:(Math.random()-0.5)*10, size:Math.random()*3+1, color:c, life:1});
}
function spawnText(t,x,y,c){ floatingTexts.push({text:t,x:x,y:y,color:c,life:1}); }

function updateEffects() {
    particles = particles.filter(p => {
        if(p.type === 'slash') { p.life--; return p.life > 0; }
        p.x+=p.vx; p.y+=p.vy; p.life-=0.05; return p.life>0;
    });
    floatingTexts = floatingTexts.filter(t => { t.y-=1; t.life-=0.02; return t.life>0; });
    player.ghosts = player.ghosts.filter(g => { g.alpha-=0.05; return g.alpha>0; });
}

function gameWin() {
    gameActive = false;
    document.getElementById("gameOver").style.display = 'flex';
    document.getElementById("endTitle").innerText = "SISTEMA LIMPO";
    document.getElementById("endTitle").style.color = "#00ff41";
    document.getElementById("finalScore").innerText = "Score Final: " + Math.floor(score + 5000);
}
function gameOver() {
    gameActive = false;
    document.getElementById("gameOver").style.display = 'flex';
}
function restartGame() {
    gameActive=true; score=0; difficultyFactor=0.6;
    player.hp=100; player.x=WORLD_SIZE/2; player.y=WORLD_SIZE/2;
    enemies=[]; items=[]; bossActive=false; bossSummoned=false;
    document.getElementById("gameOver").style.display='none';
    document.getElementById("bossHud").style.display='none';
    spawnItem(); spawnItem(); spawnItem();
    loop();
}

initMap();
function loop() {
    if(gameActive) requestAnimationFrame(loop);
    update();
    draw();
}
loop();
</script>
</body>
</html>